# 字符类型

####字符

计算机是只识别01编码的，所以和数字一样我们要想办法把字符也映射为一串01的记号，数字类型采用十进制与二进制的转换解决了这个问题，然而字符和数字本身是没有直接联系的，但是字符和01的对应关系反而更简单。因为我们只需要规定一个01序列串和字符之间对应的关系表就可以了。

**ASCII**
我们用两个字节，8位（相应可以表示256个符号）来对应一些我们常用的字符，这一套规范的对照表就是ASCII码，但是ASCII码只使用了后7位（第八位置为0）规定了与常用的128个字符（这些字符是a-z，A-Z，0-9以及一些标点符号和控制符号）的对应关系。

ASCII码是针对英语字符进行的规范，但不同的国家使用的语言不同，不同国家规定的对照表也就不同，这时用多种不同的对照表去解析一个字符很容易出现不同的结果，正因为不同国家对同一个01序列串表示的字符不同（也就是符号的编码和解码方式不同），所以在编码和解码规则不一致时会出现乱码的问题。因此我们需要一个通用的编码、解码规范（即是一个能将世界上常用的字符和01序列串进行对应的对照表）。

**Unicode**
为了解决上述的问题，提出了Unicode字符集，它规定了字符和01序列串的对应关系，但没有给出具体的存储方式。因为英文字符用一个字节就足以表示，但是汉语字符可能要需要2个字节才能表示。如果以两个字节为单位进行存储，英文字符又会浪费掉一部分存储空间。

**UTF-8**
UTF-8用一种变长的存储方式解决了上述问题。为了让计算机能区分变长字符存储真正需要的字节数，UTF-8做出如下规定：

1. 对于单字节字符，字节第一位是0，后面七位为这个符号的Unicode码，因此英文字母的Unicode码实际上和ASCII码是一致的。
2. 对于需要N个字节来存储的符号，第一个字节的前N位置为1，第N+1位置为0，后面N-1个字节的前两位都是10。比如三个字节存储的字符对应为:`1110xxxx 10xxxxxx 10xxxxxx`

这里UTF-8只是Unicode编码的一种存储实现，相应的还有UTF-16和UTF-32。


####字符和字符串
