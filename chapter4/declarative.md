### 声明式编程

声明式编程范式的编程风格是只描述问题的逻辑关系，而不是具体解决过程。通常声明式程序由一系列的逻辑条件组成，程序执行时会找出满足这些逻辑的情况作为结果。简单的说声明式编程解决问题的思路是通过陈述（声明）描述问题是什么而不是通过流程控制问题该如何解决。这样做的好处能尽可能的减少副作用，甚至无副作用，因此声明式编程在处理并行问题时更有优势。

满足声明式编程风格的范式或者说子范式（我个人觉得范式之间没有明确的继承关系，而是互相穿插的）包括如下：

1. 约束编程
2. 领域专属语言
3. 逻辑编程
4. 函数式编程

在介绍声明式编程的子范式之前，我想先介绍一些，声明式及其子范式下一些编程技巧（或者说是编程风格）。

####声明式编程技巧

**列表推导式**

声明式编程中常用的数据结构为列表和元组，通常一个列表作为输入，输出一个变化后的新列表，列表推导式也是这样的技巧，将一个规则约束于原列表，推导出一个满足这个规则的新列表。

```haskell
[ x * 2 | x <- [1,2,3,4], x > 2]    --[6,8]
```
列表推导式语法和数学中集合推导式是一致的，`{x * 2 | x ∊ N, 2 < x < 5 }` 表示取2到5之间的正整数乘2。同理，上述代码表示取集合中满足`x > 2`的元素做`x * 2`运算返回一个新的列表即：`[6, 8]`。

接下来我会简单介绍下约束编程和领域专属语言，然后相对详细的说明下逻辑编程，至于函数式编程范式，我会拿出一章来详细说明。

#### 满足声明式风格的编程范式

**约束编程**

约束编程规定了变量之间的一种约束关系，它不强调具体要执行哪一步计算，只是规定了变量的一些属性。简单的说，就是数学中方程式的概念，约束只定义了方程式的定义域，并没有指明具体解如何求解，但是解肯定是满足这个域的。

```
y = x + 1, x ∊ {1,2}
```

依上面的约束可以得知y的值域应该为`{2,3}`。

约束式编程一般作为其他范式的一种补充，我们来看看基于逻辑范式的`prolog`和基于函数范式的`haskell`下是如何表现的：

```prolog
/* prolog */
equation(X, Y) :- X == 1, Y is X + 1.
equation(X, Y) :- X == 2, Y is X + 1.
```

执行：

```prolog
equation(1, Y).    /* Y = 2 */
equation(3, Y).    /* no */
```

这里定义了一个推断`equation`，当断言`x == 1`成立时，则执行`is`运算将Y绑定为`X+1`，Prolog通过断言和推断返回查询结果`Y=2`。如果断言不成立，程序无法查询到Y值，则返回`no`。

```haskell
--haskell
equation x
 | x == 1 = x + 1
 | x == 2 = x + 1
 | otherwise = error "no"
```

执行：

```haskell
equation 1    --2
equation 3    --Exception: no
```

这里定义了一个函数，对传入参数x依次匹配各个模式，如果满足当前模式则返回操作结果，否则执行下一个模式，当传入参数为1时，满足第一个模式返回`x+1=2`，当传入参数为3时，前两个模式都不匹配，因此执行`otherwise`抛出一个异常。

**领域专属语言**

领域专属语言（DSLs：Domain-specific languages）是针对某一特定问题而设计的语言，常见的领域专属语言如正则表达式、结构化查询语言（linq）、标记语言（html）。

应用场景：

1. 作为命令行工具或者编译程序的标准用户输入接口，比如grep的正则表达式匹配
2. 通过编程语言的宏机制实现内部DSL拓展语言的表述能力，比如Lisp的mcro，Ruby的DSL
3. 作为某语言的内置库，增强其表达能力，比如微软的Linq
4. 用通用编程语言解决一个特定的问题，嵌入到宿主程序中，比如用perl实现一个正则引擎

**逻辑编程**

**函数式编程**

